{"ast":null,"code":"import { DOMEventHandlerUtil } from './_DOMEventHandlerUtil';\nimport { ElementStyleUtil } from './_ElementStyleUtil';\nimport { getElementOffset } from './DomHelpers';\nexport class ElementAnimateUtil {\n  static animate(from, to, duration, update, complete) {\n    /**\n     * TinyAnimate.easings\n     *  Adapted from jQuery Easing\n     */\n    const easings = {\n      linear: function (t, b, c, d) {\n        return c * t / d + b;\n      }\n    }; // Create mock done() function if necessary\n\n    if (!complete) {\n      complete = function () {};\n    } // Animation loop\n    // let canceled = false;\n\n\n    const change = to - from;\n\n    function loop(timestamp) {\n      var time = (timestamp || +new Date()) - start;\n\n      if (time >= 0) {\n        update(easings.linear(time, from, change, duration));\n      }\n\n      if (time >= 0 && time >= duration) {\n        update(to);\n\n        if (complete) {\n          complete();\n        }\n      } else {\n        window.requestAnimationFrame(loop);\n      }\n    }\n\n    update(from); // Start animation loop\n\n    const start = window.performance && window.performance.now ? window.performance.now() : +new Date();\n    window.requestAnimationFrame(loop);\n  }\n\n  static animateClass(element, animationName, callBack) {\n    const animateClasses = animationName.split(' ');\n    animateClasses.forEach(cssClass => element.classList.add(cssClass));\n    DOMEventHandlerUtil.one(element, 'animationend', function () {\n      animateClasses.forEach(cssClass => element.classList.remove(cssClass));\n    });\n\n    if (callBack) {\n      DOMEventHandlerUtil.one(element, 'animationend', callBack);\n    }\n  }\n\n  static transitionEnd(element, callBack) {\n    DOMEventHandlerUtil.one(element, 'transitionend', callBack);\n  }\n\n  static animationEnd(element, callBack) {\n    DOMEventHandlerUtil.one(element, 'animationend', callBack);\n  }\n\n  static animationDelay(element, value) {\n    ElementStyleUtil.set(element, 'animation-delay', value);\n  }\n\n  static animationDuration(element, value) {\n    ElementStyleUtil.set(element, 'animation-duration', value);\n  }\n\n  static scrollTo(element, offset, duration = 500) {\n    let targetPos = element ? getElementOffset(element).top : 0;\n    let scrollPos = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;\n\n    if (offset) {\n      scrollPos += offset;\n      targetPos = targetPos - offset;\n    }\n\n    const from = scrollPos;\n    const to = targetPos;\n    ElementAnimateUtil.animate(from, to, duration, function (value) {\n      document.documentElement.scrollTop = value; // document.body.parentNode.scrollTop = value;\n\n      document.body.scrollTop = value;\n    }); //, easing, done\n  }\n\n  static scrollTop(offset, duration) {\n    ElementAnimateUtil.scrollTo(null, offset, duration);\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}