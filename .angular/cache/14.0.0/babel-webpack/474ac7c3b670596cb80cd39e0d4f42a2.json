{"ast":null,"code":"import { ElementStyleUtil } from './_ElementStyleUtil';\nimport { DataUtil } from './_DataUtil';\nimport { ElementAnimateUtil } from './ElementAnimateUtil';\nimport { getObjectPropertyValueByKey, toJSON } from './_TypesHelpers';\n\nfunction getCSS(el, styleProp) {\n  const defaultView = (el.ownerDocument || document).defaultView;\n\n  if (!defaultView) {\n    return '';\n  } // sanitize property name to css notation\n  // (hyphen separated words eg. font-Size)\n\n\n  styleProp = styleProp.replace(/([A-Z])/g, '-$1').toLowerCase();\n  return defaultView.getComputedStyle(el, null).getPropertyValue(styleProp);\n}\n\nfunction getCSSVariableValue(variableName) {\n  let hex = getComputedStyle(document.documentElement).getPropertyValue(variableName);\n\n  if (hex && hex.length > 0) {\n    hex = hex.trim();\n  }\n\n  return hex;\n}\n\nfunction getElementActualCss(el, prop, cache) {\n  let css = '';\n\n  if (!el.getAttribute('kt-hidden-' + prop) || cache === false) {\n    let value; // the element is hidden so:\n    // making the el block so we can meassure its height but still be hidden\n\n    css = el.style.cssText;\n    el.style.cssText = 'position: absolute; visibility: hidden; display: block;';\n\n    if (prop === 'width') {\n      value = el.offsetWidth;\n    } else if (prop === 'height') {\n      value = el.offsetHeight;\n    }\n\n    el.style.cssText = css; // store it in cache\n\n    if (value !== undefined) {\n      el.setAttribute('kt-hidden-' + prop, value.toString());\n      return parseFloat(value.toString());\n    }\n\n    return 0;\n  } else {\n    // store it in cache\n    const attributeValue = el.getAttribute('kt-hidden-' + prop);\n\n    if (attributeValue || attributeValue === '0') {\n      return parseFloat(attributeValue);\n    }\n  }\n}\n\nfunction getElementActualHeight(el) {\n  return getElementActualCss(el, 'height', false);\n}\n\nfunction getElementActualWidth(el, cache) {\n  return getElementActualCss(el, 'width', false);\n}\n\nfunction getElementIndex(element) {\n  if (element.parentNode) {\n    const c = element.parentNode.children;\n\n    for (let i = 0; i < c.length; i++) {\n      if (c[i] === element) return i;\n    }\n  }\n\n  return -1;\n} // https://developer.mozilla.org/en-US/docs/Web/API/Element/matches\n\n\nfunction getElementMatches(element, selector) {\n  const p = Element.prototype;\n  const f = p.matches || p.webkitMatchesSelector;\n\n  if (element && element.tagName) {\n    return f.call(element, selector);\n  } else {\n    return false;\n  }\n}\n\nfunction getElementOffset(el) {\n  // Return zeros for disconnected and hidden (display: none) elements (gh-2310)\n  // Support: IE <=11 only\n  // Running getBoundingClientRect on a\n  // disconnected node in IE throws an error\n  if (!el.getClientRects().length) {\n    return {\n      top: 0,\n      left: 0\n    };\n  } // Get document-relative position by adding viewport scroll to viewport-relative gBCR\n\n\n  const rect = el.getBoundingClientRect();\n  const win = el.ownerDocument.defaultView;\n\n  if (win) {\n    return {\n      top: rect.top + win.pageYOffset,\n      left: rect.left + win.pageXOffset\n    };\n  }\n\n  return rect;\n}\n\nfunction getElementParents(element, selector) {\n  // Element.matches() polyfill\n  if (!Element.prototype.matches) {\n    Element.prototype.matches = function (s) {\n      const matches = (document || this.ownerDocument).querySelectorAll(s);\n      let i = matches.length;\n\n      while (--i >= 0 && matches.item(i) !== this) {}\n\n      return i > -1;\n    };\n  } // Set up a parent array\n\n\n  const parents = [];\n  let el = element; // Push each parent element to the array\n\n  for (; el && el !== document.body; el = el.parentElement) {\n    if (selector) {\n      if (el.matches(selector)) {\n        parents.push(el);\n      }\n\n      continue;\n    }\n\n    parents.push(el);\n  } // Return our parent array\n\n\n  return parents;\n}\n\nfunction getHighestZindex(el) {\n  let bufferNode = el;\n  let buffer = el;\n\n  while (bufferNode && bufferNode !== document) {\n    // Ignore z-index if position is set to a value where z-index is ignored by the browser\n    // This makes behavior of this function consistent across browsers\n    // WebKit always returns auto if the element is positioned\n    const position = buffer.style.getPropertyValue('position');\n\n    if (position === 'absolute' || position === 'relative' || position === 'fixed') {\n      // IE returns 0 when zIndex is not specified\n      // other browsers return a string\n      // we ignore the case of nested elements with an explicit value of 0\n      // <div style=\"z-index: -10;\"><div style=\"z-index: 0;\"></div></div>\n      const value = parseInt(buffer.style.getPropertyValue('z-index'));\n\n      if (!isNaN(value) && value !== 0) {\n        return value;\n      }\n    }\n\n    bufferNode = bufferNode.parentNode;\n    buffer = bufferNode;\n  }\n\n  return null;\n}\n\nfunction getScrollTop() {\n  return (document.scrollingElement || document.documentElement).scrollTop;\n} // https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth\n\n\nfunction getViewPort() {\n  return {\n    width: window.innerWidth,\n    height: window.innerHeight\n  };\n}\n\nfunction insertAfterElement(el, referenceNode) {\n  var _a;\n\n  return (_a = referenceNode.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(el, referenceNode.nextSibling);\n}\n\nfunction isElementHasClasses(element, classesStr) {\n  const classes = classesStr.split(' ');\n\n  for (let i = 0; i < classes.length; i++) {\n    if (!element.classList.contains(classes[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction isVisibleElement(element) {\n  return !(element.offsetWidth === 0 && element.offsetHeight === 0);\n} // Throttle function: Input as function which needs to be throttled and delay is the time interval in milliseconds\n\n\nfunction throttle(timer, func, delay) {\n  // If setTimeout is already scheduled, no need to do anything\n  if (timer) {\n    return;\n  } // Schedule a setTimeout after delay seconds\n\n\n  timer = window.setTimeout(function () {\n    func(); // Once setTimeout function execution is finished, timerId = undefined so that in <br>\n    // the next scroll event function execution can be scheduled by the setTimeout\n\n    timer = undefined;\n  }, delay);\n}\n\nfunction getElementChildren(element, selector) {\n  if (!element || !element.childNodes) {\n    return null;\n  }\n\n  const result = [];\n\n  for (let i = 0; i < element.childNodes.length; i++) {\n    const child = element.childNodes[i]; // child.nodeType == 1 => Element, Text, Comment, ProcessingInstruction, CDATASection, EntityReference\n\n    if (child.nodeType === 1 && getElementMatches(child, selector)) {\n      result.push(child);\n    }\n  }\n\n  return result;\n}\n\nfunction getElementChild(element, selector) {\n  const children = getElementChildren(element, selector);\n  return children ? children[0] : null;\n}\n\nfunction isMobileDevice() {\n  let test = getViewPort().width < +getBreakpoint('lg') ? true : false;\n\n  if (test === false) {\n    // For use within normal web clients\n    test = navigator.userAgent.match(/iPad/i) != null;\n  }\n\n  return test;\n}\n\nfunction slide(el, dir, speed, callback) {\n  if (!el || dir === 'up' && isVisibleElement(el) === false || dir === 'down' && isVisibleElement(el) === true) {\n    return;\n  }\n\n  speed = speed ? speed : 600;\n  let calcHeight = getElementActualHeight(el);\n  let calcPaddingTop = 0;\n  let calcPaddingBottom = 0;\n\n  if (ElementStyleUtil.get(el, 'padding-top') && DataUtil.get(el, 'slide-padding-top') !== true) {\n    DataUtil.set(el, 'slide-padding-top', ElementStyleUtil.get(el, 'padding-top'));\n  }\n\n  if (ElementStyleUtil.get(el, 'padding-bottom') && DataUtil.has(el, 'slide-padding-bottom') !== true) {\n    DataUtil.set(el, 'slide-padding-bottom', ElementStyleUtil.get(el, 'padding-bottom'));\n  }\n\n  if (DataUtil.has(el, 'slide-padding-top')) {\n    const data = DataUtil.get(el, 'slide-padding-top');\n    calcPaddingTop = parseInt(data);\n  }\n\n  if (DataUtil.has(el, 'slide-padding-bottom')) {\n    const data = DataUtil.get(el, 'slide-padding-bottom');\n    calcPaddingBottom = parseInt(data);\n  }\n\n  if (dir === 'up') {\n    // up\n    el.style.cssText = 'display: block; overflow: hidden;';\n\n    if (calcPaddingTop) {\n      ElementAnimateUtil.animate(0, calcPaddingTop, speed, function (value) {\n        el.style.paddingTop = calcPaddingTop - value + 'px';\n      });\n    }\n\n    if (calcPaddingBottom) {\n      ElementAnimateUtil.animate(0, calcPaddingBottom, speed, function (value) {\n        el.style.paddingBottom = calcPaddingBottom - value + 'px';\n      });\n    }\n\n    ElementAnimateUtil.animate(0, calcHeight || 0, speed, function (value) {\n      el.style.height = (calcHeight || 0) - value + 'px';\n    }, function () {\n      el.style.height = '';\n      el.style.display = 'none';\n\n      if (typeof callback === 'function') {\n        callback();\n      }\n    });\n  } else if (dir === 'down') {\n    // down\n    el.style.cssText = 'display: block; overflow: hidden;';\n\n    if (calcPaddingTop) {\n      ElementAnimateUtil.animate(0, calcPaddingTop, speed, function (value) {\n        //\n        el.style.paddingTop = value + 'px';\n      }, function () {\n        el.style.paddingTop = '';\n      });\n    }\n\n    if (calcPaddingBottom) {\n      ElementAnimateUtil.animate(0, calcPaddingBottom, speed, function (value) {\n        el.style.paddingBottom = value + 'px';\n      }, function () {\n        el.style.paddingBottom = '';\n      });\n    }\n\n    ElementAnimateUtil.animate(0, calcHeight || 0, speed, function (value) {\n      el.style.height = value + 'px';\n    }, function () {\n      el.style.height = '';\n      el.style.display = '';\n      el.style.overflow = '';\n\n      if (typeof callback === 'function') {\n        callback();\n      }\n    });\n  }\n}\n\nfunction slideUp(el, speed, callback) {\n  slide(el, 'up', speed, callback);\n}\n\nfunction slideDown(el, speed, callback) {\n  slide(el, 'down', speed, callback);\n}\n\nfunction getBreakpoint(breakpoint) {\n  let value = getCSSVariableValue('--kt-' + breakpoint);\n\n  if (value) {\n    value = parseInt(value.trim());\n  }\n\n  return value;\n}\n\nfunction getAttributeValueByBreakpoint(incomingAttr) {\n  let value = toJSON(incomingAttr);\n\n  if (typeof value !== 'object') {\n    return incomingAttr;\n  }\n\n  const width = getViewPort().width;\n  let resultKey;\n  let resultBreakpoint = -1;\n  let breakpoint;\n\n  for (let key in value) {\n    if (key === 'default') {\n      breakpoint = 0;\n    } else {\n      breakpoint = getBreakpoint(key) ? +getBreakpoint(key) : parseInt(key);\n    }\n\n    if (breakpoint <= width && breakpoint > resultBreakpoint) {\n      resultKey = key;\n      resultBreakpoint = breakpoint;\n    }\n  }\n\n  return resultKey ? getObjectPropertyValueByKey(value, resultKey) : value;\n}\n\nfunction colorLighten(color, amount) {\n  const addLight = (_color, _amount) => {\n    const cc = parseInt(_color, 16) + _amount;\n\n    const cNum = cc > 255 ? 255 : cc;\n    const c = cNum.toString(16).length > 1 ? cNum.toString(16) : `0${cNum.toString(16)}`;\n    return c;\n  };\n\n  color = color.indexOf('#') >= 0 ? color.substring(1, color.length) : color;\n  amount = parseInt((255 * amount / 100).toString());\n  return color = `#${addLight(color.substring(0, 2), amount)}${addLight(color.substring(2, 4), amount)}${addLight(color.substring(4, 6), amount)}`;\n}\n\nfunction colorDarken(color, amount) {\n  const subtractLight = (_color, _amount) => {\n    const cc = parseInt(color, 16) - amount;\n    const cNum = cc < 0 ? 0 : cc;\n    const c = cNum.toString(16).length > 1 ? cNum.toString(16) : `0${cNum.toString(16)}`;\n    return c;\n  };\n\n  color = color.indexOf('#') >= 0 ? color.substring(1, color.length) : color;\n  amount = parseInt((255 * amount / 100).toString());\n  return color = `#${subtractLight(color.substring(0, 2), amount)}${subtractLight(color.substring(2, 4), amount)}${subtractLight(color.substring(4, 6), amount)}`;\n}\n\nexport { getBreakpoint, getCSS, getCSSVariableValue, getElementActualCss, getElementActualHeight, getElementActualWidth, getElementIndex, getElementMatches, getElementOffset, getElementParents, getHighestZindex, getScrollTop, getViewPort, insertAfterElement, isElementHasClasses, isVisibleElement, throttle, getElementChildren, getElementChild, isMobileDevice, slide, slideUp, slideDown, getAttributeValueByBreakpoint, colorLighten, colorDarken };","map":null,"metadata":{},"sourceType":"module"}